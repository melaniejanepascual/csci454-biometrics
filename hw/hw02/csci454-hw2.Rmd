---
title: "csci454-hw2"
author: "MJ Pascual"
date: "October 28, 2017"
output: html_document
---

## Principal Component Analysis
In this assignment, you will implement the Principal Component Analysis method for face recognition (see below). Using a set of training images, you will compute the set of Eigenvectors to find the principal components representing the face space. Using a subset, the first ten (10) Eigenvectors, you will find the corresponding weighted sum of the Eigenvectors for each image in the testing set and perform a face matching experiment. Distance scores will be calculated by subtracting the weights ωi from ωj and summing their total LaTeX: ∑(ωi−ωj).

Using the distance scores calculated from each image pair, you will perform an all vs. all matching experiment to create a distance matrix. Next, you will plot the genuine and impostor distributions using the same implementation as Homework Assignment 1. Finally, you will plot the DET curve (FAR vs. FRR), line of equal error, and estimate the Equal Error Rate.

## Step 1
Implement the each image as a d-dimensional column vector x1, x2,...,xN and compute the average µ. 

The mean is the row-wise mean when all of the images are stored in a single matrix. Compute average of training set
```{r}
library("png")

filepath = "~/Developments/csci454-biometrics/hw/hw02/trainingfaces2/"
filenames = list.files(filepath, pattern = "*.png")
fullpathnames = paste(filepath, filenames, sep="")

images <- c()
for(i in 1:length(fullpathnames)) {
  images <- cbind(images, as.vector(readPNG(fullpathnames[i])))
}

the.mean <- rowMeans(images)
xmean <- apply(images, 1, function(x) x-the.mean)

```

## Step 2
Define the matrix X as the follows: X = [(x1-µ) (x2-µ) ... (xN-µ)]. X is a d x N matrix.

```{r}
xt.matrix <- t(xmean)
```

## Step 3
Calculate the covariance matrix C = XXT, where XT is the transpose of X. d by N multiplied by a N by d matrix is results in a d by d matrix.
```{r}
covariance <- xmean %*% xt.matrix;
```

## Step 4
Compute the Eigenvectors of the covariance matrix C by solving the following Eigen system: CE = 𝜆E (The right size of the equation is scalar multiplication, and the left side is matrix multiplication.)
```{r}
ev = eigen(covariance)
ten.eigen.vectors <- ev$vectors[,1:10]
et <- t(ten.eigen.vectors)

```

## Step 5 
Any vector x can be represented as a weighted sum of the Eigenvectors, ω = ETx, where ωj is the weight associated with the Eigenvector ej
```{r}
weight <- et %*% xmean
```

## Testing data

``` {r}
filepath.test = "~/Developments/csci454-biometrics/hw/hw02/testingfaces2/"
filenames.test = list.files(filepath.test, pattern = "*.png")
fullpathnames.test = paste(filepath.test, filenames.test, sep="")

images.test <- c()
for(i in 1:length(fullpathnames.test)) {
  d <- cbind(as.vector(readPNG(fullpathnames.test[i])))
  images.test <- cbind(images.test, et %*% d)
}

## subtract the difference between 2 columns, get the absolute and then sum everything up = which equals to the distance scores
difference <- c()
for(i in c(1:dim(images.test[2]))) {
    difference <- cbind(abs())
}

```

## Hw 1
Using the distance scores calculated from each image pair, you will perform an all vs. all matching experiment to create a distance matrix. Next, you will plot the genuine and impostor distributions using the same implementation as Homework Assignment 1. Finally, you will plot the DET curve (FAR vs. FRR), line of equal error, and estimate the Equal Error Rate.


```{r}
scores <- read.csv("hw1_list.csv")
scores$Match <- ifelse(substr(scores$sequence1,1,6) == substr(scores$sequence2,1,6),"Genuine", "Imposter")
genuine.scores <- subset(scores, Match == "Genuine")
imposter.scores <- subset(scores, Match == "Imposter")
```

## 1) Distribution of Genuine and Imposter Scores

```{r}
hist(genuine.scores$score, col = rgb(1,0,0,0.5), main = "Genuine and Imposter Distribution", xlab = "Distance Scores", ylab = "Frequency", freq = FALSE)
hist(imposter.scores$score, col = rgb(0,0,1,0.5), add = T, freq = FALSE)
legend("top", c("Genuine", "Imposter"), fill=c(rgb(1,0,0,0.5), rgb(0,0,1,0.5)))


```

## 2) D-prime
```{r}
genuine.sd <- sd(genuine.scores$score)
imposter.sd <- sd(imposter.scores$score)
genuine.mean <- mean(genuine.scores$score)
imposter.mean <- mean(imposter.scores$score)

dprime <- (sqrt(2) * abs((genuine.mean)-(imposter.mean)))/sqrt((genuine.sd^2)+(imposter.sd^2))

```

D-prime is approximately 


## 3) Detection Error Tradeoff (DET) Curve

```{r}
  FAR <- c()
  FRR <- c()
  
for(threshold in seq(0.2, 0.99, 0.02)) {
  far.formula <-nrow(subset(imposter.scores, imposter.scores$score < threshold))/nrow(imposter.scores)
  FAR <- c(FAR, far.formula)
  frr.formula <- nrow(subset(genuine.scores, genuine.scores$score >= threshold))/nrow(genuine.scores)
  FRR <- c(FRR, frr.formula)
}

x <- seq(0.0, 0.3, 0.1)
y <- seq(0.0, 0.3, 0.1)

  
plot(FAR, FRR, xlim = range(0 , 0.75), ylim = range (0, 0.35), type = "l", col = "blue")
lines(x, y, col = "red")

```

Equal Error Rate is approximately 