---
title: "csci454-hw2"
author: "MJ Pascual"
date: "October 28, 2017"
output: html_document
---

## Principal Component Analysis
In this assignment, you will implement the Principal Component Analysis method for face recognition (see below). Using a set of training images, you will compute the set of Eigenvectors to find the principal components representing the face space. Using a subset, the first ten (10) Eigenvectors, you will find the corresponding weighted sum of the Eigenvectors for each image in the testing set and perform a face matching experiment. Distance scores will be calculated by subtracting the weights ωi from ωj and summing their total LaTeX: ∑(ωi−ωj).

Using the distance scores calculated from each image pair, you will perform an all vs. all matching experiment to create a distance matrix. Next, you will plot the genuine and impostor distributions using the same implementation as Homework Assignment 1. Finally, you will plot the DET curve (FAR vs. FRR), line of equal error, and estimate the Equal Error Rate.

## Step 1
Implement the each image as a d-dimensional column vector x1, x2,...,xN and compute the average µ. 

The mean is the row-wise mean when all of the images are stored in a single matrix. Compute average of training set
```{r}
library("png")

# Reading in training image 1
img1 = readPNG("~/Developments/csci454-biometrics/hw/hw02/trainingfaces2/1_0.png")
vec_img1 = as.vector(img1)

img2 = readPNG("~/Developments/csci454-biometrics/hw/hw02/trainingfaces2/2_0.png")
vec_img2 = as.vector(img2)

filepath = "~/Developments/csci454-biometrics/hw/hw02/trainingfaces2/"
filenames = list.files(filepath, pattern = "*.png")
fullpathnames = paste(filepath, filenames, sep="")


images.matrix = cbind(vec_img1, vec_img2)
images.matrix = t(images.matrix)
```

## Step 2
Define the matrix X as the follows: X = [(x1-µ) (x2-µ) ... (xN-µ)]. X is a d x N matrix.

```{r}
x.matrix

## create a for loop that iterates through all of the vectors and subtracts the mean from each vector?
for(1:180) {
  
}
```

## Step 3
Calculate the covariance matrix C = XXT, where XT is the transpose of X. d by N multiplied by a N by d matrix is results in a d by d matrix.
```{r}
xt <- t(x)
covariance <- x * xt
```

## Step 4
Compute the Eigenvectors of the covariance matrix C by solving the following Eigen system: CE = 𝜆E (The right size of the equation is scalar multiplication, and the left side is matrix multiplication.)
```{r}
# Lastly, you will need to use the Eigenvector solver to find the Eigenvectors 
# and Eigenvalues from the covariance matrix. This can be done using the 'eigen' 
# function.

ev = eigen(aMatrix)

# To access the Eigenvectors and Eigenvalues, use the '$' operator

ev$vectors
ev$values
```

## Step 5 
Any vector x can be represented as a weighted sum of the Eigenvectors, ω = ETx, where ωj is the weight associated with the Eigenvector ej
```{r}
et <- t(ev)
weights <- et*x
```


```{r}
scores <- read.csv("hw1_list.csv")
scores$Match <- ifelse(substr(scores$sequence1,1,6) == substr(scores$sequence2,1,6),"Genuine", "Imposter")
genuine.scores <- subset(scores, Match == "Genuine")
imposter.scores <- subset(scores, Match == "Imposter")

```

## 1) Distribution of Genuine and Imposter Scores

```{r}
hist(genuine.scores$score, col = rgb(1,0,0,0.5), main = "Genuine and Imposter Distribution", xlab = "Distance Scores", ylab = "Frequency", freq = FALSE)
hist(imposter.scores$score, col = rgb(0,0,1,0.5), add = T, freq = FALSE)
legend("top", c("Genuine", "Imposter"), fill=c(rgb(1,0,0,0.5), rgb(0,0,1,0.5)))


```

## 2) D-prime
```{r}
genuine.sd <- sd(genuine.scores$score)
imposter.sd <- sd(imposter.scores$score)
genuine.mean <- mean(genuine.scores$score)
imposter.mean <- mean(imposter.scores$score)

dprime <- (sqrt(2) * abs((genuine.mean)-(imposter.mean)))/sqrt((genuine.sd^2)+(imposter.sd^2))

```

D-prime is approximately 4.4899.


## 3) Detection Error Tradeoff (DET) Curve

```{r}
  FAR <- c()
  FRR <- c()
  
for(threshold in seq(0.2, 0.99, 0.02)) {
  far.formula <-nrow(subset(imposter.scores, imposter.scores$score < threshold))/nrow(imposter.scores)
  FAR <- c(FAR, far.formula)
  frr.formula <- nrow(subset(genuine.scores, genuine.scores$score >= threshold))/nrow(genuine.scores)
  FRR <- c(FRR, frr.formula)
}

x <- seq(0.0, 0.3, 0.1)
y <- seq(0.0, 0.3, 0.1)

  
plot(FAR, FRR, xlim = range(0 , 0.75), ylim = range (0, 0.35), type = "l", col = "blue")
lines(x, y, col = "red")

```

Equal Error Rate is approximately 0.04, 0.45. 